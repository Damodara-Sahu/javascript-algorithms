{"version":3,"sources":["components/Sidebar.js","components/Details.js","algorithms/sorting/bubble-sort.js","algorithms/sorting/quick-sort.js","algorithms/sorting/selection-sort.js","algorithms/sorting/merge-sort.js","algorithms/sorting/insertion-sort.js","algorithms/sorting/tasks/find-median.js","components/concepts/Sorting.js","algorithms/string-manipulation/define-anagrams.js","algorithms/string-manipulation/making-anagrams.js","algorithms/string-manipulation/tasks/alternating-characters.js","algorithms/string-manipulation/tasks/sherlock-valid-string.js","leetcode/string-manipulation/771-number-jewels-in-stones.js","leetcode/string-manipulation/387-first-unique-character-in-string.js","components/concepts/StringManipulation.js","eloquent-tasks/tasks/looping-triangle.js","eloquent-tasks/tasks/fizz-buzz.js","eloquent-tasks/tasks/chessboard.js","eloquent-tasks/tasks/3-chapter-functions/is-even.js","eloquent-tasks/CodeSandboxTasks.js","algorithms/greedy/min-abs-difference.js","algorithms/greedy/luck-balance.js","components/concepts/GreedyAlgorithms.js","algorithms/number/power.js","algorithms/number/swap.js","leetcode/bitwise/476-number-complement.js","components/concepts/Number.js","algorithms/recursion/factorial.js","components/concepts/Recursion.js","algorithms/array/merge-sorted-arrays.js","algorithms/array/tasks/jump-on-clouds.js","components/concepts/ArrayAlgorithms.js","algorithms/search/find-index.js","algorithms/search/binary-search.js","algorithms/search/balanced-sum.js","algorithms/search/two-sum.js","leetcode/search/binary-search/278-first-bad-version.js","components/concepts/Searching.js","algorithms/tree/binary-search-tree.js","components/concepts/Tree.js","algorithms/stack/stack-using-string.js","algorithms/stack/stack-using-objects.js","algorithms/queue/queue-using-object.js","components/concepts/StackQueue.js","components/Main.js","components/SplitSidebarView.js","config/constants.js","App.js","serviceWorker.js","index.js"],"names":["Sidebar","className","href","Details","props","id","question","solution","complexity","time","space","code","secondCode","aria-expanded","role","aria-controls","aria-hidden","language","style","docco","dark","bubbleSort","arr","swap","len","length","i","quickSort","pivot","leftArr","rightArr","slice","el","push","selectionSort","min","j","temp","merger","left","right","singleSorted","shift","concat","mergeSort","half","Math","floor","insertionSort","key","findMedian","sortedArr","index","Sorting","toString","defineAnagrams","str1","str2","Error","len1","len2","obj","normalizedStr1","replace","toLowerCase","normalizedStr2","charCodeAt","Object","values","every","val","makingAnagrams","obj1","obj2","hasOwnProperty","arr1","arr2","reduce","a","b","alternatingCharacters","s","split","deletions","count","list","value","filter","x","isValid","letters","element","valMax","max","valMin","countMax","countMin","Set","numJewelsInStonesBruteForce","J","S","charAt","numJewelsInStones","jewels","stones","hash","stone","jewel","firstUniqueChar","frequencies","char","StringManipulation","aria-labelledby","loopingTriangle","symbol","line","console","log","fizzBuzz","n","output","chessboard","size","board","y","isEven","minimumAbsoluteDifference","diff","sort","abs","luckBalance","k","contests","luck","lost","GreedyAlgorithms","power","base","exponent","undefined","result","swapUseTemp","flipBitByBit","num","bit","todo","findComplement","N","bitmask","str","parseInt","Number","factorial","Recursion","mergeSortedArrays","jumpOnClouds","c","jumps","nextStep","next2Step","ArrayAlgorithms","findIndex","searchQuery","binarySearch","target","start","end","mid","binarySearchRecursive","stop","balancedSum","sum","twoSum","previousValues","currentElement","index2","solutionBinarySearch","isBadVersion","Searching","spaceComplexity","Node","this","BinarySearchTree","root","newNode","traverseTree","node","currentNode","height","leftHeight","rightHeight","p","q","lowestCommonAncestor","tree","Tree","insert","Stack","storage","prototype","pop","lastEliminate","lastIndexOf","substr","myWeeklyMenu","StackObj","capacity","Infinity","myStack","Queue","head","tail","StackQueue","enqueue","dequeue","Main","SplitSidebarView","width","window","innerWidth","state","sideBarSize","getSize","sideBarGrowing","handleDrag","bind","onDragFinished","onResizerDoubleClick","windowWidth","setState","event","children","onChange","resizerStyle","minSize","maxSize","Component","openTarget","location","substring","detail","document","getElementById","tagName","open","App","addEventListener","Boolean","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.80389740.chunk.js","sourcesContent":["import React from 'react';\n\nimport './sidebar.css';\n\nfunction Sidebar() {\n  return (\n    <div className=\"sidebar\">\n      <a href=\"/\" className=\"logo\">Topics</a>\n      <nav>\n        <ul className=\"list\">\n          <li className=\"item\"><header className=\"title\"><a href=\"#number\">Number</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#recursion\">Recursion</a></header></li>\n          <li className=\"item\"><header className=\"title\"><a href=\"#array\">Array</a></header></li>\n\n          <li className=\"item\">\n            <header className=\"title\">Sorting</header>\n            <ul className=\"subList\">\n              <li><a href=\"#bubble-sort\">Bubble sort</a></li>\n              <li><a href=\"#selection-sort\">Selection sort</a></li>\n              <li><a href=\"#insertion-sort\">Insertion sort</a></li>\n              <li><a href=\"#merge-sort\">Merge sort</a></li>\n              <li><a href=\"#quick-sort\">Quick sort</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">String Manipulation</header>\n            <ul className=\"subList\">\n              <li><a href=\"#define-anagrams\">Define anagrams</a></li>\n              <li><a href=\"#making-anagrams\">Making anagrams</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">Greedy Algorithms</header>\n            <ul className=\"subList\">\n              <li><a href=\"#greedy-min-absolute-difference\">Minimum absolute difference</a></li>\n              <li><a href=\"#greedy-luck-balance\">Luck balance</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">Search</header>\n            <ul className=\"subList\">\n              <li><a href=\"#is-find-index\">Linear search</a></li>\n              <li><a href=\"#binary-search\">Binary search</a></li>\n\n              {/* other tasks */}\n              <li><a href=\"#search-balanced-sum\">Balanced Sum</a></li>\n              <li><a href=\"#search-two-sum\">Two Sum</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\"><a href=\"#binary-search-tree\">Tree</a></header>\n            <ul className=\"subList\">\n              <li><a href=\"#binary-search-tree-operations\">Binary Search Tree</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">Stack and Queue</header>\n            <ul className=\"subList\">\n              <li><a href=\"#stack-using-string\">Stack implementation using String</a></li>\n              <li><a href=\"#stack-using-object\">Stack implementation using object</a></li>\n              <li><a href=\"#queue-using-object\">Queue implementation using object</a></li>\n            </ul>\n          </li>\n\n          <li className=\"item\">\n            <header className=\"title\">\n              Tasks from Eloquent JavaScript\n            </header>\n            <ul className=\"subList\">\n              <li><a href=\"#eloquent-looping-triangle\">Looping a triangle</a></li>\n              <li><a href=\"#eloquent-fizz-buzz\">Fizz buzz</a></li>\n              <li><a href=\"#eloquent-chessboard\">Chessboard</a></li>\n              <li><a href=\"#eloquent-is-even\">Recursion</a></li>\n            </ul>\n          </li>\n\n        </ul>\n      </nav>\n    </div>\n  );\n}\n\nexport default Sidebar;\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco, dark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\n\n// function createMarkup(markup) {\n//   return {__html: markup};\n// }\n\nexport default function Details(props) {\n  const {\n    id,\n    question,\n    solution,\n    complexity,\n    time,\n    space,\n    code,\n    secondCode\n  } = props;\n\n  return (\n    <details\n      className=\"details\"\n      id={id}\n      aria-expanded=\"false\">\n      <summary\n        role=\"button\"\n        aria-controls=\"content\"\n      >\n        <span className=\"question\">\n          Question:&nbsp;\n          <strong>{question}</strong>\n        </span>\n      </summary>\n\n      <div aria-hidden=\"true\">\n        <h3 className=\"title\">Solution:</h3>\n        <p className=\"solutionDesc\">{solution}</p>\n        <div className=\"complexity\">\n          {/* {complexityDesc && <div dangerouslySetInnerHTML={createMarkup(complexityDesc)} />} */}\n          {complexity && <div className=\"complexityDesc\">{complexity}</div> }\n          {time && <p className=\"runtime\">time complexity is {time}</p>}\n          {space && <p>space complexity is {space}</p>}\n        </div>\n\n        {code &&\n          <SyntaxHighlighter\n            language=\"javascript\"\n            style={docco}\n          >\n            {code}\n          </SyntaxHighlighter>\n        }\n\n        {secondCode &&\n          <SyntaxHighlighter\n            language=\"javascript\"\n            style={dark}\n          >\n            {secondCode}\n          </SyntaxHighlighter>\n        }\n\n      </div>\n    </details>\n  )\n}\n","function bubbleSort(arr) {\n  const len = arr.length;\n  let swap;\n\n  do {\n    swap = false;\n    for (let i = 0; i < len-1; i++) {\n      if (arr[i] > arr[i+1]) {\n        [arr[i], arr[i+1]] =[arr[i+1], arr[i]];\n        swap = true;\n      }\n    }\n  } while (swap)\n\n  return arr;\n}\n\nfunction bubbleSortDisplayCount(arr) {\n  const len = arr.length;\n  let count = 0;\n  let swap;\n\n  do {\n    swap = false;\n    for (let i = 0; i < len-1; i++) {\n      if (arr[i] > arr[i+1]) {\n        [ arr[i], arr[i+1] ] =[ arr[i+1], arr[i] ];\n        swap = true;\n        count += 1;\n      }\n    }\n  } while (swap)\n\n  return count;\n}\n\n\nexport { bubbleSort, bubbleSortDisplayCount }\n","function quickSort(arr) {\n  const len = arr.length;\n\n  if (len <= 1) {\n    return arr;\n  }\n\n  const pivot = arr[len - 1];\n  const leftArr = [];\n  const rightArr = [];\n\n  for (const el of arr.slice(0, len - 1)) {\n    // exclude last element, because it's our pivot\n    el < pivot ? leftArr.push(el) : rightArr.push(el)\n  }\n\n  const merged = [...quickSort(leftArr), pivot, ...quickSort(rightArr)];\n  return merged;\n}\n\nexport { quickSort };\n","/**\n * Selection sort works by selecting the minimum value in a list and\n * swapping it with the first value in the list.\n *\n * It then starts at the second position, selects the smallest value in the remaining list,\n * and swaps it with the second element.\n * It continues iterating through the list and swapping elements until\n * it reaches the end of the list.\n * Now the list is sorted.\n * Selection sort has quadratic time complexity in all cases.\n */\nfunction swap(a, b, arr) {\n  let temp = arr[a];\n  arr[a] = arr[b];\n  arr[b] = temp;\n}\n\nfunction selectionSort(arr) {\n  const len = arr.length;\n\n  for (let i = 0; i < len - 1; i++) {\n    let min = i;\n    for (let j = i+1; j < len; j++) {\n      if (arr[min] > arr[j]) {\n        min = j\n      }\n    }\n\n    // or possible to use ES6 syntax\n    let temp = arr[i];\n    arr[i] = arr[min];\n    arr[min] = temp;\n    // or separate function\n    //swap(i, min, arr);\n  }\n\n  return arr;\n}\n\nexport { selectionSort, swap }\n","/**\n *  Merge sort is pretty efficient and the best way to conceptualize merge sort is recursively.\n *  So suppose we have large array and we want to sort it.\n *  What if we could magically sort the left half and sort the right half,\n *  and then get back two sorted halves.\n *  When if you want to have the whole array sorted all we have to do is merge those\n *  in in sorted order and that's merge sort is.\n *  So we apply merge sort to the left half, apply to the right half\n *  and merge those back in order\n *  It always give us n log n runtime. There is no case than array looks really funky.\n *  The downside is merging 2 arrays together requires extra space - O(n) space\n */\n\nfunction merger(left, right) {\n  let singleSorted = [];\n\n  while (left.length && right.length) {\n    if (left[0] < right[0]) {\n      singleSorted.push(left[0]);\n      left.shift();\n    } else {\n      singleSorted.push(right[0]);\n      right.shift();\n    }\n  }\n\n  // need to concat here because there will be one element remaining from either left or the right\n  return singleSorted.concat(left, right);\n}\n\nfunction mergeSort(arr) {\n  // it means we no longer divide the array into smaller chunks\n  if ( arr.length <= 1) {\n    return arr;\n  }\n\n  const half = Math.floor(arr.length / 2);\n  const left = arr.slice(0, half);\n  const right = arr.slice(half);\n\n  return merger(mergeSort(left), mergeSort(right))\n}\n\nexport { mergeSort, merger }\n","/**\n * In Insertion Sort Part 2: learning exercise\n *\n * Guideline: You already can place an element into a sorted array.\n * How can you use that code to build up a sorted array, one element at a time?\n * Note that in the first step, when you consider an array with just the first element,\n * it is already sorted since there's nothing to compare it to.\n *\n * Print the array after each iteration of the insertion sort, i.e.,\n * whenever the next element has been inserted at its correct position.\n * Since the array composed of just the first element is already sorted,\n * begin printing after placing the second element.\n *\n * For example, there are n=7 elements in [3,4,7,5,6,2,1]. Working from left to right, we get the following output:\n * 3 4 7 5 6 2 1\n * 3 4 7 5 6 2 1\n * 3 4 5 7 6 2 1\n * 3 4 5 6 7 2 1\n * 2 3 4 5 6 7 1\n * 1 2 3 4 5 6 7\n */\n\nfunction insertionSort2(n, arr) {\n  let storage;\n\n  for (let i = 1; i < n; i++) {\n    storage = arr.splice(i, 1)[0]\n\n    for (let j = i; j >= 0; j--) {\n      if (storage > arr[j-1] || j === 0) {\n        arr.splice(j, 0, storage)\n        break\n      }\n    }\n    //console.log(arr.join(' '))\n  }\n}\n// insertionSort2(7, [3,4,7,5,6,2,1]);\n\n/**\n * Insertion sort algorithm\n */\nfunction insertionSort(arr) {\n  const len = arr.length;\n\n  // can skip the first item = index 0, since any array of size 1 is trivially sorted\n  for (let i = 1; i < len; i++) {\n    const key = arr[i];\n    // look to the left\n    let j = i - 1;\n\n    // Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position\n    while (j >= 0 && arr[j] > key) {\n      arr[j+1] = arr[j];\n      j = j - 1;\n    }\n\n    arr[j+1] = key;\n  }\n\n  return arr;\n}\n\nfunction runningTimeOfInsertionSort(arr) {\n  let swap = 0;\n\n  for (let i = 1; i < arr.length; i++) {\n    const key = arr[i];\n    let j = i - 1;\n\n    while (j>=0 && arr[j] > key) {\n      swap++;\n      arr[j+1] = arr[j];\n      j = j - 1;\n    }\n\n    arr[j+1] = key;\n\n  }\n\n  return swap;\n}\n\nexport {\n  insertionSort2,\n  insertionSort, runningTimeOfInsertionSort\n}\n","import { quickSort } from '../quick-sort';\n\nfunction findMedian(arr) {\n  const len = arr.length;\n  const sortedArr = quickSort(arr);\n\n  let median;\n  if (len === 0) return median = 0;\n\n  let index = 0;\n\n  if (len % 2 === 0) {\n    index = len / 2;\n    median = (sortedArr[index] + sortedArr[index - 1]) / 2\n  } else {\n    index = Math.floor(len / 2);\n    median = sortedArr[index]\n  }\n\n  return median\n}\n\nfunction findMedianVariant1(arr) {\n  const n = arr.length;\n  arr = arr.sort((a, b) => a - b);\n  return arr[(n - 1)/2];\n}\n\nexport { findMedian, findMedianVariant1 }\n","import React from 'react';\nimport Details from './../Details';\nimport { bubbleSort } from '../../algorithms/sorting/bubble-sort';\nimport { quickSort } from '../../algorithms/sorting/quick-sort';\nimport { selectionSort } from '../../algorithms/sorting/selection-sort';\nimport { mergeSort, merger } from '../../algorithms/sorting/merge-sort';\nimport { insertionSort } from '../../algorithms/sorting/insertion-sort';\nimport { findMedian } from '../../algorithms/sorting/tasks/find-median';\n\nfunction Sorting() {\n  return (\n    <div className=\"sorting\">\n      <h2>Sorting</h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"bubble-sort\"\n            question=\"Bubble sort: bubble up the biggest element to the right most position\"\n            solution=\"is a method for sorting arrays by comparing each array element to the element behind it\"\n            complexity=\"Unfortunately bubble sort is pretty slow\"\n            time=\"(n-1) * (n-1) ... = n2 - 2n + 1 = O(n^2), Ω(n^2)\"\n            space=\"O(1)\"\n            code={bubbleSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"selection-sort\"\n            question=\"Selection sort: move the smallest element to the very left position\"\n            solution=\"\"\n            complexity=\"n + (n-1) + (n-2) + ... + 1 = n*(n+1)/2 = (n^2 + n)/2 = O(n^2)\"\n            time=\"O(n^2) quadratic in all cases, Ω(n^2)\"\n            space=\"\"\n            code={selectionSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"insertion-sort\"\n            question=\"Insertion sort: compare items on its left and shift if needed\"\n            solution={`\n              Insertion sort is used when number of elements is small.\n              It can also be useful when input array is almost sorted,\n              only few elements are misplaced in complete big array.\n            `}\n            complexity=\"in worst cases number of shifts over that number to the beginning of the array = 1 + 2 + ... + (n-1) = n(n-1)/2 = n^2/2 = n^2\"\n            time=\"O(n^2)\"\n            space=\"O(1)\"\n            code={insertionSort.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"merge-sort\"\n            question=\"Merge sort\"\n            solution=\"we could magically sort the left half and sort the right half and repeat it again\"\n            complexity=\"It always give us O(n log n) runtime. There is no case than array looks really funky.\"\n            time=\"O(n log n)\"\n            space=\"The downside is merging 2 arrays together requires extra space - O(n) space\"\n            code={mergeSort.toString()}\n            secondCode={merger.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"quick-sort\"\n            question=\"Quick sort: pick a pivot\"\n            solution=\"first pick a random number - pivot\"\n            complexity=\"Quick sort’s worst case is O(n^2) (for example, if list was already sorted) but that can be avoided if we pick random pivot point (choose middle one)\"\n            time=\"O(n log(n))\"\n            space=\"O(log (n))\"\n            code={quickSort.toString()}\n          />\n        </li>\n\n        {/* other tasks */}\n        <li>\n          <Details\n            id=\"find-median\"\n            question=\"Find a median\"\n            solution=\"The median of a list of numbers is essentially it's middle element after sorting. The same number of elements occur after it as before.\"\n            time=\"\"\n            space=\"\"\n            code={findMedian.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n\nexport default Sorting;\n","function defineAnagrams(str1, str2) {\n  if (typeof str1 !== 'string' || typeof str2 !== 'string') {\n    throw new Error('defineAnagrams requires two strings to be passed');\n  }\n\n  if ( str1 === '' || str2 === '') return 'empty strings';\n\n  const len1 = str1.length;\n  const len2 = str2.length;\n  let obj = {}; // hash\n\n  if (len1 !== len2) return false;\n\n  if (len1 === len2) {\n    const normalizedStr1 = str1.replace(/[^A-Za-z]+/g, '').toLowerCase();\n    const normalizedStr2 = str2.replace(/[^A-Za-z]+/g, '').toLowerCase();\n\n    for (let i = 0; i < len1; i++) {\n      const index = normalizedStr1.charCodeAt(i)-97;\n      obj[index] = (obj[index] || 0) + 1;\n     }\n\n    for (let j = 0; j < len2; j++) {\n      const index = normalizedStr2.charCodeAt(j)-97;\n      if (!obj[index]) return false;\n      else {\n        obj[index]--;\n      }\n    }\n\n    const isStringAnagram = Object.values(obj).every(val => val === 0);\n    return isStringAnagram;\n  }\n}\n\nexport { defineAnagrams }\n","/**\n * Given two strings, a and b, that may or may not be of the same length,\n * determine the minimum number of character deletions required to make a and b anagrams.\n * Any characters can be deleted from either of the strings.\n * For example, if a = cde and b = dcf, we can delete e from string a and\n * f from string b so that both remaining strings are  and  which are anagrams.\n */\nfunction makingAnagrams(str1, str2) {\n  const len1 = str1.length\n  const len2 = str2.length;\n  const obj1 = {};\n  const obj2 = {};\n\n  for (let i=0; i < len1; i++) {\n    obj1[str1[i]] = obj1[str1[i]] ? obj1[str1[i]] + 1 : 1\n  }\n\n  for (let j=0; j < len2; j++) {\n    obj2[str2[j]] = obj2[str2[j]] ? obj2[str2[j]] + 1 : 1\n  }\n\n  for (let i =0; i<len1; i++) {\n    if (obj2.hasOwnProperty(str1[i])) {\n      obj2[str1[i]]--;\n      if (obj2[str1[i]] === 0) {\n        delete obj2[str1[i]]\n      }\n    }\n  }\n\n  for (let j=0; j< len2; j++) {\n    if (obj1.hasOwnProperty(str2[j])) {\n      obj1[str2[j]]--;\n      if (obj1[str2[j]] === 0) {\n        delete obj1[str2[j]];\n      }\n    }\n  }\n\n  const arr1 = Object.values(obj1);\n  const arr2 = Object.values(obj2);\n  const sum1 = ((arr1.length > 0) && arr1.reduce((a,b) => a + b)) || 0;\n  const sum2 = ((arr2.length > 0) && arr2.reduce((a,b) => a+b)) || 0;\n  const sum = sum1 + sum2;\n\n  return sum;\n}\n\nexport { makingAnagrams }\n","/**\n * You are given a string containing characters A and B only.\n * Your task is to change it into a string such that there are no matching adjacent characters.\n *  To do this, you are allowed to delete zero or more characters in the string.\n *\n*/\n\nfunction alternatingCharacters(s) {\n  let arr = s.split('');\n  const len = arr.length - 1;\n  let deletions = 0;\n\n\n  for (let index = 0; index < len; index++) {\n    if (arr[index] === arr[index + 1]) {\n      deletions++;\n    }\n  }\n\n  return deletions;\n}\n\nfunction alternatingCharactersVariant1(s) {\n  let deletions = 0;\n\n  s.split('').map((char, i) => {\n    if (char[i] === char[i+1]) deletions++;\n    return deletions;\n  })\n}\n\nexport { alternatingCharacters, alternatingCharactersVariant1 }\n","/**\n * Sherlock considers a string to be valid if all characters of the string\n * appear the same number of times.\n *\n*/\nexport const count = (list, value) => {\n  return list.filter((x) => x === value).length\n}\n\nfunction isValid(s) {\n  const arr = s.split('');\n  const len = arr.length;\n  let letters = {};\n\n  for (let i = 0; i < len; i++) {\n    const element = arr[i];\n    letters[element] = (letters[element] || 0) + 1;\n  }\n\n  const values = Object.values(letters);\n  const valMax = Math.max(...values)\n  const valMin = Math.min(...values);\n\n  const countMax = count(values, valMax);\n  const countMin = count(values, valMin);\n  let isValid = false;\n\n  if (\n    (valMax === valMin) ||\n    (valMax - valMin === 1 && countMax === 1) ||\n    (valMin === 1 && countMin === 1 && [...new Set(values)].length === 2)\n  ) {\n    isValid = true\n  }\n\n  return isValid === true ? 'Yes' : 'No';\n}\n\nfunction isValidVariant1(s) {\n  let h = {};\n  let res = \"Yes\";\n  let arr = [];\n  let count = 0;\n\n  for (let char of s) {\n    h[char] = h[char]+1 || 1; // if any char appear more than once, value will increment;\n  }\n\n  Object.values(h).map(v => {\n    arr.push(v);\n    // if any value is different than first value;\n    if ( v !== arr[0] ){\n      count++;  // count how many values are different\n      if( (v > arr[0]) && (v-1 !== arr[0]) ){\n        res = \"No\";\n      } else if ( (v < arr[0]) &&  (v !== (arr[0]-1)) ){\n        console.log(v, arr[0])\n        res = \"Yes\"\n      }\n    }\n    return res = \"No\";\n  })\n\n  if (count > 1) res = \"NO\"; // if more than one values are different\n  if (count === 1) res = \"YES\"; // if only one value is different\n  return res;\n}\n\nexport { isValid, isValidVariant1 }\n\n","/**\n * Leetcode\n * 771 Number Jewels in stones\n * Easy\n *\n * You're given strings J representing the types of stones that are jewels,\n * and S representing the stones you have.\n * Each character in S is a type of stone you have.\n * You want to know how many of the stones you have are also jewels.\n *\n * The letters in J are guaranteed distinct,\n * and all characters in J and S are letters.\n * Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n *\n * Hint:\n * For each stone, check if it is a jewel.\n */\n\n/**\n * Approach 1: Brute force\n *\n * Time complexity: O(J.length * S.length)\n * Space complexity O(1) additional space complexity in Python.\n * In Java, this can be O(J.length∗S.length)) because of the creation of new arrays.\n */\nvar numJewelsInStonesBruteForce = function(J,S) {\n  let count = 0;\n  for (let i = 0; i < S.length; i++) { // for each stone\n    for (let j = 0; j < J.length; j++) { // for each jewel\n      if (J.charAt(j) === S.charAt(i)) { // if the stone is a jewel...\n        count++;\n        break; // stop searching whether this stone 's' is a jewel\n      }\n    }\n  }\n  return count;\n}\n\n/**\n * Approach 2 hash set\n *\n * Time Complexity: O(J.length + S.length)).\n * The O(J.length) part comes from creating J.\n * O(S.length) part comes from searching S.\n *\n * Space Complexity: O(S.length)\n */\n var numJewelsInStones = function(J, S) {\n  let count = 0;\n  if ((S.length || J.length) === 0) {\n    count = 0\n  }\n\n  const jewels = J.split('');\n  const stones = S.split('');\n  const hash = {}\n\n  for (let i = 0; i < S.length; i++) {\n    const stone = stones[i];\n    hash[stone] = hash[stone] ? hash[stone] + 1 : 1\n  }\n\n  for (let j = 0; j < J.length; j++) {\n    const jewel = jewels[j];\n    if (hash[jewel]) {\n      count = count + hash[jewel]\n    }\n  }\n\n  return count;\n};\n\nvar numJewelsInStonesUseForIn = function(J, S) {\n  let hash = {};\n  let count = 0;\n\n  for (let j in J) {\n    hash[J[j]] = j\n  }\n\n  for (let i in S) {\n    if (hash[S[i]]) {\n      count++\n    }\n  }\n  return count\n};\n\n// use includes\nvar numJewelsInStonesUseIncludes = function(J, S) {\n  if (!J || !S) {\n    return 0\n  }\n\n  let count = 0;\n  for (const char of S) {\n    if (J.includes(char)) count++\n  }\n\n  return count;\n}\n\n// use indexOf method\n// Actually, due to indexOf being a loop under the hood,\n// this is quadratic (O(n2)) time complexity = O(J.length * S.length), when it could be linear O(n)\nvar numJewelsInStonesUseIndexOf = function(J, S) {\n  if (!J || !S) {\n    return 0\n  }\n\n  let result = 0;\n  for (let i = 0; i < S.length; i++) {\n   if ( J.indexOf(S.charAt(i)) !== -1 ) result++\n  }\n\n  return result;\n}\n\n// use filter\nvar numJewelsInStonesUseFilter = function(J, S) {\n  return [...S].filter((char) => J.indexOf(char) > -1 ).length\n}\n\n// reduce and set\n// This is O(S) space and time - could be taken down to O(J) space by normal iteration.\nconst numJewelsInStonesUseSet = (J, S) => {\n  const jewels = new Set(J);\n  return S.split('').reduce((res, s) => res + jewels.has(s), 0);\n};\n\nconst numJewelsInStonesUseReduce = (J, S) => {\n  const set = new Set(J);\n  return S.split('').reduce(\n    (count, curr) => (set.has(curr) ? ++count : count),\n    0\n  );\n};\n\nexport {\n  numJewelsInStones,\n  numJewelsInStonesBruteForce,\n  numJewelsInStonesUseForIn,\n  numJewelsInStonesUseIncludes,\n  numJewelsInStonesUseIndexOf,\n  numJewelsInStonesUseFilter,\n  numJewelsInStonesUseSet,\n  numJewelsInStonesUseReduce\n}\n","/**\n * Leetcode\n * 387 First Unique Character in a String\n * easy\n *\n * Given a string, find the first non-repeating character in it and return it's index.\n * If it doesn't exist, return -1.\n *\n * Note: You may assume the string contain only lowercase letters.\n *\n * Approach linear time solution\n * The best possible solution here could be of a linear time\n * because to ensure that the character is unique you have to check the whole string anyway.\n *\n * Time complexity : O(N) since we go through the string of length N two times.\n * Space complexity : O(N) since we have to keep a hash map with N elements.\n */\nvar firstUniqueChar = function(s) {\n  const frequencies = {};\n\n  for (const char of s) {\n    frequencies[char] = (frequencies[char] || 0) + 1;\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    // first non-repeating character\n    if (frequencies[char] === 1) {\n      return i\n    }\n  }\n\n  return -1\n}\n\nexport {firstUniqueChar }\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco, dark } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport Details from './../Details';\nimport { defineAnagrams } from '../../algorithms/string-manipulation/define-anagrams';\nimport { makingAnagrams } from '../../algorithms/string-manipulation/making-anagrams';\nimport { alternatingCharacters } from '../../algorithms/string-manipulation/tasks/alternating-characters';\nimport { isValid } from '../../algorithms/string-manipulation/tasks/sherlock-valid-string';\nimport { numJewelsInStones, numJewelsInStonesBruteForce } from '../../leetcode/string-manipulation/771-number-jewels-in-stones';\nimport { firstUniqueChar } from '../../leetcode/string-manipulation/387-first-unique-character-in-string';\n\nexport default function StringManipulation() {\n  return (\n    <div className=\"sorting\">\n      <h2>String Manipulation</h2>\n      <ul>\n        <li>\n          <details\n            className=\"details\"\n            id=\"define-anagrams\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>define anagrams</strong>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <p>\n                Anagrams are 2 words meaning anagrams with the same characters but in different order\n                (same exact characters but order doesn’t matter).\n              </p>\n              <ul className=\"unorderedList\">\n                <li>Define hash</li>\n                <li>Increase the count for the first string.</li>\n                <li>Decrease the count for the second string. If a letter in string 2 is not found in the hash then return false.</li>\n                <li>else return true</li>\n              </ul>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {defineAnagrams.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"making-anagrams\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>making anagrams</strong>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <p>\n                Given two strings, a and b, that may or may not be of the same length,\n                determine the minimum number of character deletions required to make a and b anagrams.\n                Any characters can be deleted from either of the strings.\n              </p>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {makingAnagrams.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"string-manipulation-tasks\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">Different tasks related to String Manipulation</summary>\n              <Details\n                id=\"alternating-characters\"\n                question=\"Alternating characters\"\n                solution={`\n                  Given two strings, a and b, that may or may not be of the same length,\n                  determine the minimum number of character deletions required to make a and b anagrams.\n                  Any characters can be deleted from either of the strings.\n                `}\n                code={alternatingCharacters.toString()}\n              />\n\n              <Details\n                id=\"sherlock-valid-string\"\n                question=\"Sherlock valid string\"\n                solution={`\n                  Sherlock considers a string to be valid if all characters of the string\n                  appear the same number of times and one symbol could be deleted.\n                `}\n                code={isValid.toString()}\n              />\n\n              <Details\n                id=\"numJewelsInStones\"\n                question=\"Number Jewels in stones\"\n                code={numJewelsInStones.toString()}\n                secondCode={numJewelsInStonesBruteForce.toString()}\n              />\n\n              <Details\n                id=\"firstUniqueChar\"\n                question=\"First Unique Character in a String\"\n                complexity={`\n                  The best possible solution here could be of a linear time\n                  because to ensure that the character is unique you have to check the whole string anyway.\n                `}\n                time=\"O(n)\"\n                space=\"O(n)\"\n                code={firstUniqueChar.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/**\n  *   Looping a triangle\n  *   Write a loop that makes seven calls to console.log to output the following triangle:\n  *   #\n  *   ##\n  *   ###\n  *   ####\n  *   #####\n  *   ######\n  *   #######\n*/\nfunction loopingTriangle(len, symbol='#') {\n  for (let line = symbol; line.length < len + 1; line += symbol) {\n    console.log('line', line);\n  }\n}\n\nfunction drawPyramid(h) {\n  let line = '#';\n  for (let i = 0; i <= h; i++) {\n    for (let j = 1; j < i; j++) {\n      line += '#';\n\n    }\n    console.log('line', line)\n  }\n}\n\n/**\n * Draw a pyramid by recursion means\n * draw pyramid of size n-1 + additional row, for example\n * if h = 4, draw(4-1) + one additional loop\n */\nfunction drawPyramidUsingRecursion(h) {\n  let line = '#';\n  // exclude for negative numbers\n  if (h === 0) {\n    return\n  }\n\n  drawPyramid(h-1)\n  for (let i = 0; i < h; i++) {\n    line += '#';\n  }\n  console.log('line recursion', line)\n}\n\n export { loopingTriangle, drawPyramid, drawPyramidUsingRecursion }\n","/**\n * Create a for loop that iterates up to 100 while outputting \"fizz\" at multiples of 3, \"buzz\" at multiples of 5 and \"fizzbuzz\" at multiples of 3 and 5\n *\n * 1\n * 2\n * 'Fizz'\n * 4\n * 'Buzz'\n * ..\n * @param {for loop numbers}\n * @return {or number or string}\n */\n\nconst fizzBuzz = () => {\n  for (let n = 1; n <= 100; n++) {\n    let output = \"\";\n    if (n % 3 === 0)\n      output += \"Fizz\";\n    if (n % 5 === 0)\n      output += \"Buzz\";\n\n    console.log(output || n);\n  }\n};\n\nexport { fizzBuzz }\n","/**\n *\n * Write a program that creates a string that represents an 8×8 grid,\n * using newline characters to separate lines.\n * At each position of the grid there is either a space or a \"#\" character.\n * The characters should form a chessboard.\n * Passing this string to console.log should show something like this:\n *\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *   # # # #\n *\n*/\nexport function chessboard(size=8) {\n  let board = '';\n\n  // lines\n  for (let y = 0; y < size; y++) {\n    // characters\n    for (let x = 0; x < size; x++) {\n      if ( (x+y) % 2 === 0) {\n        board += ' ';\n      } else {\n        board += '#'\n      }\n    }\n    board += '\\n';\n  }\n\n  console.log(board)\n}\n","function isEven(n) {\n  if ( n % 2 === 0) {\n    return true\n  } else if (n === 1 ) {\n    return false\n  } else if (n < 0) {\n    return isEven(-n)\n  } else return isEven(n-2)\n}\n\n/**\n * Chapter 3 functions\n * Bean Counting\n*/\nfunction countChar(str, letter) {\n  let count = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === letter) {\n      count++\n    }\n  }\n\n  return count;\n}\n\nfunction countBs(str) {\n  return countChar(str, 'B')\n}\n\nexport { isEven, countBs, countChar}\n","import React from 'react';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport Details from '../components/Details';\nimport { loopingTriangle } from './tasks/looping-triangle';\nimport { fizzBuzz } from './tasks/fizz-buzz';\nimport { chessboard } from './tasks/chessboard';\nimport { isEven } from './tasks/3-chapter-functions/is-even';\n\nexport default function StringManipulation() {\n  return (\n    <div className=\"sorting\">\n      <h2>\n        Code Sandbox <br />\n        <a href=\"https://eloquentjavascript.net/\">Eloquent JavaScript</a>\n      </h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"eloquent-looping-triangle\"\n            question=\"Looping triangle\"\n            solution=\"Write a loop that makes seven calls to console.log to output the triangle\"\n            code={loopingTriangle.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"eloquent-fizz-buzz\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>\n                  fizzbuzz\n                </strong>\n                <p>\n                  Create a for loop that iterates up to 100 while outputting \"fizz\" at multiples of 3,\n                  \"buzz\" at multiples of 5 and \"fizzbuzz\" at multiples of 3 and 5\n                </p>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <span className=\"complexity\">\n                runtime - O(n)\n              </span>\n\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {fizzBuzz.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"eloquent-fizz-buzz\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>\n                  Chessboard\n                </strong>\n                <p>\n                  Write a program that creates a string that represents an 8×8 grid, using newline characters\n                  to separate lines. At each position of the grid there is either a space or a \"#\" character.\n                  The characters should form a chessboard.\n                </p>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <span className=\"complexity\">complexity - n2</span>\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                { chessboard.toString() }\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n\n        <li>\n          <Details\n            id=\"eloquent-is-even\"\n            question=\"Define whether a positive whole number is even or odd (using recursion): Zero is even, One is odd, for any other number N, its evenness is the same as N - 2.\"\n            code={isEven.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/**\n * Consider an array of integers, arr = [arr[0], ... , arr[n-1]].\n * We define the absolute difference between two elements a[i] and a[j] (where i!=j),\n * to be the absolute value of a[i] - a[j].\n * Given an array of integers,\n * find and print the minimum absolute difference between any two elements in the array.\n * For example, given the array arr = [-2,2,4]\n * we can create  pairs of numbers: [-2,2], [-2,4] and [2,4].\n * The absolute differences for these pairs are\n * |-2 -2| = 4,\n * |-2-4| = 6 and\n * |2-4| = 2.\n * The minimum absolute difference is 2.\n *\n * Algorithm\n * 1) sort\n * 2) consider diff between the first pair as min\n * 3) compare all \"consecutive pair min\" with the one in step2 to get the least min.\n * */\nfunction minimumAbsoluteDifference(arr) {\n  const len = arr.length;\n  const sortedArr = arr.sort((a, b) => a - b); // solution doesn't work without sort\n\n  let min = Math.abs(sortedArr[0] - sortedArr[1]),\n    diff;\n\n  for (let i = 2; i < len; i++) {\n    diff = Math.abs(sortedArr[i] - sortedArr[i-1]);\n    if (diff < min) {\n      min = diff;\n    }\n  }\n\n  return min;\n}\n\nexport { minimumAbsoluteDifference }\n\n","/**\n * More description on hackerrunk greedy algorithms\n * The description would be clearer if it read \"L is the amount of luck\n * that can be gained by losing the contest.\"\n * She believes that luck is spent on wins and earned from losses.\n*/\nfunction luckBalance(k, contests) {\n  // sort descending, don't modify the original array\n  const arr = contests\n    .slice()\n    .sort((a, b) => b[0] - a[0]);\n\n  const len = arr.length;\n  let luck = 0,\n    lost = k;\n\n  for (let i = 0; i < len; i++) {\n      const [value, important] = arr[i];\n      // increment if lost, decrement if won\n      if (important) {\n          luck += lost > 0 ? value : -value;\n          lost -= 1;\n          continue;\n      }\n      // non-important are always lost\n      luck += value;\n  }\n\n  return luck;\n}\n\nexport { luckBalance }\n","import React from 'react';\nimport Details from '../Details';\nimport SyntaxHighlighter from 'react-syntax-highlighter';\nimport { docco } from 'react-syntax-highlighter/dist/esm/styles/hljs';\nimport { minimumAbsoluteDifference } from '../../algorithms/greedy/min-abs-difference';\nimport { luckBalance } from '../../algorithms/greedy/luck-balance';\n\n\nexport default function GreedyAlgorithms() {\n  return (\n    <div className=\"sorting\">\n      <h2>Greedy Algorithms</h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"greedy-min-absolute-difference\"\n            question=\"Minimum absolute difference in an array\"\n            solution=\"We define the absolute difference between two elements a[i] and a[j] (where i!=j), to be the absolute value of a[i] - a[j].\"\n            code={minimumAbsoluteDifference.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"greedy-luck-balance\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n            <summary role=\"button\" aria-controls=\"content\">\n              <span className=\"question\">\n                Question:&nbsp;\n                <strong>Luck Balance</strong>\n              </span>\n            </summary>\n\n            <div aria-hidden=\"true\">\n              <h3 className=\"title\">Solution:</h3>\n              <SyntaxHighlighter\n                language=\"javascript\"\n                style={docco}\n              >\n                {luckBalance.toString()}\n              </SyntaxHighlighter>\n            </div>\n          </details>\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","function power(base, exponent) {\n  if (exponent === undefined) exponent = 2;\n\n  let result = 1;\n\n  for (let count = 0; count < exponent; count++) {\n    result *= base;\n  }\n\n  return result\n}\n\n/**\n * Recursion usually ten times slower than loops\n */\nfunction powerUsingRecursion(base, exponent) {\n  if ( exponent === 0) {\n    return 1\n  } else {\n    return base * powerUsingRecursion(base, exponent - 1)\n  }\n}\n\nexport { power, powerUsingRecursion }\n","/**\n * Swap a number\n *\n * @param {number1, number2}\n * @return {number2, number1}\n */\n\n/*\n  Approach 1\n  time complexity O(1)\n*/\nconst swap = function(a,b) {\n  //console.log('before swap: ','a: ', a, 'b: ', b);\n  b = b - a; // b = 4 - 3 = 1\n  a = a + b; // a = 3 + 1 = 4\n  b = a - b; // b = 4 - 1 = 3\n\n  return [a, b];\n}\n\n/*\n  Use temp\n  time complexity O(1)\n*/\nconst swapUseTemp = function(a,b) {\n  let temp = a;\n  a = b;\n  b = temp;\n\n  return [a,b];\n}\n\n/**\n * Bitwise operators treat their operands as a sequence of 32 bits (zeroes and ones),\n * rather than as decimal, hexadecimal, or octal numbers.\n *\n * For example, the decimal number nine has a binary representation of 1001.\n * Bitwise operators perform their operations on such binary representations,\n * but they return standard JavaScript numerical values.\n */\n\nconst swapNumberUseBitwise = (a, b) => {\n  a = a ^ b;\n  b = a ^ b;\n  a = a ^ b;\n\n  return [a, b];\n};\n\nexport { swap, swapUseTemp, swapNumberUseBitwise  }\n","/**\n * Leetcode javascript\n * 1009. Complement of Base 10 Integer\n * 476. Number complement\n * easy\n *\n * Given a positive integer, output its complement number.\n * The complement strategy is to flip the bits of its binary representation.\n * 5 -> 101\n * 11 -> 1011\n * Note that except for N = 0, there are no leading zeroes in any binary representation\n *\n*/\n\n/**\n * Approach 1 Flip Bit by bit\n * To move along the number and flip bit by bit.\n *\n * Initiate 1-bit variable which will be used to flip bits one by one. Set it to the smallest register bit = 1.\n * Initiate the marker variable which will be used to stop the loop over the bits todo = num.\n *\n * Loop over the bits. While todo != 0:\n *  Flip the current bit: num = num ^ bit.\n *  Prepare for the next run. Shift flip variable to the left and todo variable to the right.\n *  Return num\n *\n *  Time Complexity: O(1), since we're doing not more than 32 iterations here\n *  Space complexity O(1)\n */\n\nvar flipBitByBit = function(num) {\n  let bit = 1;\n  let todo = num;\n\n  while (todo) {\n     // flip current bit\n    num = num ^ bit;\n     // prepare for next run\n     bit = bit << 1; // Shift flip variable to the left\n     todo = todo >> 1; // todo variable to the right\n  }\n  return num\n}\n\n/*\n  Approach 2 use toString and parseInt\n\n  Time complexity is O(1), because toString operates from 2 through 36 bits.\n*/\nvar bitwiseComplement = function(N) {\n  const bitmask = N.toString(2);\n  let flip = [];\n  for (let i = 0; i < bitmask.length; i++) {\n    let bit = 1;\n    if (Number(bitmask[i]) === 1) {\n      bit = 0\n    }\n    flip.push(bit)\n  }\n\n  const complement = flip.join('');\n  return parseInt(complement, 2);\n}\n\n// second variant\nvar findComplement = function(N) {\n  const bitmask = N.toString(2);\n  let str = '';\n  for (const i of bitmask) {\n    str += +!(i-0);\n  }\n  return parseInt(str, 2);\n}\n\n\n// approach without toString and parseInt\nconst power = function(base, exponent) {\n  if (exponent === 0) return 1\n  return base * power(base, exponent - 1)\n}\n\nvar bitwiseComplementUseReduce = function(N) {\n  const num = N.toString(2);\n  let flip = [];\n  for (let i = 0; i < num.length; i++) {\n    let bit = 1;\n    if (Number(num[i]) === 1) {\n      bit = 0\n    }\n    flip.push(bit)\n  }\n\n  const len = flip.length;\n  const complement = flip.map((val, index) => {\n    index = index + 1; // todo explain\n    return power(2, len - index) * val\n  })\n\n  const decimal = complement.reduce((accumulator, currentValue) => {\n    return accumulator + currentValue\n  }, 0)\n\n  return decimal\n}\n\n/*\n  the math\n  (1) 11 / 2 = 5\n  (1) 5 / 2 = 2\n  (0) 2 / 2 = 1\n  (1) 1 / 2 = 0\n\n  todo: doesn't work with 0 case\n*/\nfunction decimalToBinary(inputNum) {\n  let binary = [];\n\n  while (inputNum > 0) {\n    if (inputNum % 2 === 1) {\n      binary.splice(0,0,1);\n      inputNum = (inputNum - 1) / 2;\n    } else {\n      binary.splice(0,0,0);\n      inputNum /= 2;\n    }\n  }\n\n  binary = binary.join('');\n  return binary;\n}\n\nexport {\n  bitwiseComplement, findComplement, bitwiseComplementUseReduce, flipBitByBit,\n  decimalToBinary\n}\n","import React from 'react';\nimport Details from './../Details';\nimport { power } from '../../algorithms/number/power';\nimport { swap, swapUseTemp } from '../../algorithms/number/swap';\nimport { flipBitByBit, findComplement } from '../../leetcode/bitwise/476-number-complement';\n\nexport default function Number() {\n  return (\n    <div className=\"number\">\n      <h2>Number</h2>\n\n      <ul id=\"number\">\n        <li>\n          <Details\n            id=\"number-power\"\n            question=\"Write a power function\"\n            code={power.toString()}\n          />\n\n          <Details\n            id=\"number-swap\"\n            question=\"Swap: 2 variables\"\n            time=\"O(1)\"\n            code={swap.toString()}\n            secondCode={swapUseTemp.toString()}\n          />\n\n          <Details\n            id=\"number-complement\"\n            question=\"Complement of Base 10 Integer\"\n            solution=\"The complement strategy is to flip the bits of its binary representation\"\n            time=\"O(1)\"\n            space=\"O(1)\"\n            code={flipBitByBit.toString()}\n            secondCode={findComplement.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n","const loopNTimes = function(n) {\n  if ( n <= 1) {\n    return 'complete'\n  }\n  return loopNTimes(n-1);\n}\n\n/**\n * Factorial of a Number: return the factorial of the provided integer.\n * Desc: if the integer is represented with the n, a factorial is the product\n * of all positive integers less than or equal to n.\n *\n * solution(5) --> 5! = 1 * 2 * 3 * 4 * 5 = 120\n * 0! = 1\n * 1! = 1\n * 2! = 2 * 1\n * 3! = 3 * 2 * 1\n * 4! = 4 * 3 * 2 * 1\n * 5! = 5 * 4 * 3 * 2 * 1\n *\n * position of stack trace\n *\n * First Part of the recursion method\n * You need to remember that you won’t have just one call, you’ll have several nested calls\n * Each call: n === \"?\"        \t          n * factorial(n - 1)\n * 1st call: factorial(5) will return     5 * factorial(5 - 1) // -> factorial(4)\n * 2nd call – factorial(4) will return    4 * factorial(4 - 1) // factorial(3)\n * 3rd call – factorial(3) will return    3 * factorial(3 - 1) // factorial(2)\n * 4th call – factorial(2) will return    2 * factorial(2 - 1) // factorial(1)\n * 5th call – factorial(1) will return    1 * factorial(1 - 1) // factorial(0)\n *\n * Second part of the recursion method\n * The method hits the if condition, it returns 1 which num will multiply itself with\n * The function will exit with the total value\n * 5th call will return (5 * (5 - 1))     // n = 5 * 4\n * 4th call will return (20 * (4 - 1))    // n = 20 * 3\n * 3rd call will return (60 * (3 - 1))    // n = 60 * 2\n * 2nd call will return (120 * (2 - 1))   // n = 120 * 1\n * 1st call will return (120)             // n = 120\n * If we sum up all the calls in one line, we have\n * (5 * (5 - 1) * (4 - 1) * (3 - 1) * (2 - 1)) = 5 * 4 * 3 * 2 * 1 = 120\n *\n * @param {number}\n * @return {number}\n*/\nfunction factorialUseLoop(n) {\n  //console.time('test-factorialUseLoop');\n  let result = 1;\n\n  for (let i = 2; i <= n; i++) {\n    result *= i\n  }\n\n  //console.timeEnd('test-factorialUseLoop');\n  return result;\n}\n\nfunction factorialUseLoopOperatorMinus(n) {\n  //console.time('test-factorialUseLoopOperatorMinus');\n  if ( n < 0 ) {\n    return -1;\n  }\n\n  if (n === 0 || n === 1 ) {\n    return 1;\n  }\n\n  for (let i = n - 1; i >= 1; i--) {\n    n = n * i\n  }\n\n  //console.timeEnd('test-factorialUseLoopOperatorMinus');\n  return n;\n}\n\nfunction factorialUseWhileLoop(n) {\n  //console.time('test-factorialUseWhileLoop');\n  let result = n;\n  if ( n < 0 ) {\n    result = -1;\n  }\n\n  if (n === 0 || n === 1) {\n    result = 1\n  }\n\n  while (n > 1) {\n    n--;\n    result *= n;\n  }\n\n  //console.timeEnd('test-factorialUseWhileLoop');\n  return result;\n}\n\nfunction factorial(n) {\n  //console.time('test-factorial');\n  // if the number is less than 0, reject it\n  if ( n < 0 ) {\n    return -1;\n  }\n\n  // works with (n === 1) as well\n  if (n === 0) {\n    return 1;\n  } else {\n    //console.timeEnd('test-factorial');\n    return n * factorial(n - 1);\n  }\n}\n\nexport { factorialUseLoop, factorial, factorialUseWhileLoop, factorialUseLoopOperatorMinus, loopNTimes }\n","import React from 'react';\nimport Details from './../Details';\nimport { factorial } from \"../../algorithms/recursion/factorial\";\n\nexport default function Recursion() {\n  return (\n    <div className=\"number\">\n      <h2>Recursion</h2>\n\n      <ul id=\"recursion\">\n        <li>\n          <Details\n            id=\"factorial\"\n            question=\"Factorial using recursion\"\n            time=\"The time complexity of recursive factorial is O(n)\"\n            space=\"As there is no extra space taken during the recursive calls, the space complexity is O(n)\"\n            code={factorial.toString()}\n          />\n        </li>\n      </ul>\n  </div>\n  );\n}\n","/**\n * Write a function which merges two sorted arrays of integers\n * and prints result\n * runtime O(n log n)\n * Below is just merge sort algorithm\n *\n * @param {array, array}\n * @return {array} - sorted\n */\n\nconst mergeSortedArrays = (arr1, arr2) => {\n  let i = 0, // initial index for the first array\n    j = 0, // initial index for the second array,\n    result = [];\n\n  const len1 = arr1.length,\n    len2 = arr2.length;\n\n  while (i < len1 && j < len2 ) {\n    if (arr1[i] < arr2[j]) {\n      result.push(arr1[i]);\n      i++;\n    } else {\n      result.push((arr2[j]));\n      j++;\n    }\n  }\n\n  if (i < len1) {\n    result = [...result, ...arr1.slice(i)];\n  }\n\n  if (j < len2) {\n    result = [...result, ...arr2.slice(j)];\n  }\n\n  return result;\n};\n\n// other solution but also with a loop\nconst mergeSortedArrays1 = (arr1, arr2) => {\n    let i = 1,\n        j = 1,\n        firstArr1 = arr1[0],\n        firstArr2 = arr2[0],\n        merged = [];\n\n    const len1 = arr1.length,\n        len2 = arr2.length;\n\n    // case if one array is empty\n    if (len1 === 0) {\n        return arr2;\n    }\n    if (len2 === 0) {\n        return arr1;\n    }\n\n    // if firstArr1 or firstArr2 exists we will insert to merged array\n    // will go inside while loop\n    // to insert: firstArr1 exists and firstArr2 doesn't exists\n    // or both exists and firstArr1 < firstArr2\n    // this is the critical part of the example\n    while(firstArr1 || firstArr2) {\n        if ( (firstArr1 && !firstArr2) || firstArr1 < firstArr2 ) {\n            merged.push(firstArr1);\n            firstArr1 = arr1[i++];\n        } else {\n            merged.push(firstArr2);\n            firstArr2 = arr2[j++];\n        }\n    }\n\n    return merged;\n};\n\nexport { mergeSortedArrays, mergeSortedArrays1  };\n","/**\n * The girl jumps from one cloud to another, but wants to avoid the thunder clouds:\n * jumps types available = 1 space jump or 2 spaces jump\n * c = array of clouds container 1 or 0\n * 0 = regular cloud\n * 1 = thunder cloud\n */\nfunction jumpOnClouds(c) {\n  const len = c.length;\n  let jumps = 0;\n\n  for (let i = 0; i < len; i++) {\n    let nextStep = c[i+1];\n    let next2Step = c[i+2];\n\n    if (c[i] === 1) {\n      i += 1\n    } else {\n      if (nextStep === 0 && next2Step === 0) {\n        jumps += 2;\n        i = i + 2;\n      } else {\n        jumps += 1;\n        i += 1\n      }\n    }\n  }\n\n  return jumps;\n}\n\nexport { jumpOnClouds }\n","import React from 'react';\nimport Details from './../Details';\nimport { mergeSortedArrays } from '../../algorithms/array/merge-sorted-arrays';\nimport { jumpOnClouds } from '../../algorithms/array/tasks/jump-on-clouds';\n\n\nexport default function ArrayAlgorithms() {\n  return (\n    <div className=\"sorting\">\n      <h2>Array</h2>\n\n      <ul id=\"array\">\n        {/* different task */}\n        <li>\n          <Details\n            id=\"array-jump-on-clouds\"\n            question=\"Jump on clouds\"\n            solution=\"\"\n            code={jumpOnClouds.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"merge-two-arrays\"\n            question=\"merge two sorted arrays (mergeSort algorithm)\"\n            solution=\"Below is just an implementation of mergeSort algorithm\"\n            time=\"runtime is O(n log n)\"\n            space=\"\"\n            code={mergeSortedArrays.toString()}\n          />\n        </li>\n\n      </ul>\n  </div>\n  );\n}\n","/**\n * Linear Search (array a, value x)\n *\n * Algorithm:\n * Step 1: Set i to 1\n * Step 2: if i > n then go to step 7\n * Step 3: if a[i] = x then go to step 6\n * Step 4: Set i to i + 1\n * Step 5: Go to Step 2\n * Step 6: Print Element x Found at index i and go to step 8\n * Step 7: Print element not found\n * Step 8: Exit\n *\n * Characteristics:\n * The worst case performance scenario for a linear search is that\n * it needs to loop through the entire collection;\n * either because the item is the last one, or because the item isn't found.\n * In other words, if you have N items in your collection,\n * the worst case scenario to find an item is N iterations.\n * This is known as runtime O(n) using the Big O Notation.\n * The speed of search grows linearly with the number of items within your collection.\n *\n * @param {array, number}\n * @return {number | undefined}\n */\n\nexport function findIndex(arr, searchQuery) {\n  const len = arr.length;\n\n  for (let index = 0; index < len; index++) {\n    const element = arr[index];\n    if (element === searchQuery) {\n      return index\n    } else return undefined\n  }\n}\n","/**\n * Binary search must always operated on sth which is sorted\n * and returns either the index of the location in the array,\n * or -1 if the array did not contain the targetValue.\n *\n * You probably already have an intuitive idea that binary search makes fewer guesses than linear search\n*/\nfunction binarySearch(arr, target) {\n  arr = arr.sort((a, b) => a - b);\n  const len = arr.length;\n  let start = 0;\n  let end = len - 1;\n\n\n  while (start <= end) {\n    // left + right could overflow\n    let mid = Math.floor(start + (end - start)/2)\n\n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      start = mid + 1;\n    } else {\n      end = mid - 1;\n    }\n  }\n\n  return -1;\n}\n\nfunction binarySearchRecursive(arr, target, start = 0, stop = (arr.length - 1)) {\n  // left + right could overflow\n  // let midPoint = Math.floor((start + stop) / 2);\n  let mid = Math.floor(start + (stop - start)/2)\n\n  switch (true) {\n    case arr[mid] === target:\n      return mid;\n\n    case stop - start === 0:\n      return -1;\n\n    case arr[mid] < target:\n      return binarySearchRecursive(arr, target, mid + 1, stop);\n\n    case arr[mid] > target:\n      return binarySearchRecursive(arr, target, start, mid);\n\n    default:\n      console.log('Sorry, we are out of expressions');\n  }\n}\n\nexport { binarySearch, binarySearchRecursive }\n","/**\n * Search\n * Sherlock and array\n * Watson gives Sherlock an array of integers.\n * His challenge is to find an element of the array such that the sum of all elements\n * to the left is equal to the sum of all elements to the right.\n * For instance, given the array [5, 6, 8, 11], 8 is between two subarrays that sum to 11.\n * If your starting array is [1], that element satisfies the rule as left and right sum to 0.\n *\n * Complete the balancedSums function in the editor below. It should return a string,\n * either YES if there is an element meeting the criterion or NO otherwise.\n */\n\nfunction balancedSum(arr) {\n  const len = arr.length;\n  if (len <= 0) return 'YES';\n\n  let i = 0;\n  let j = len - 1;\n  let sum = 0;\n  while (i !== j) {\n    if (sum >= 0) {\n\n      sum -= arr[j];\n      j--;\n    } else {\n      sum +=arr[i];\n      i++;\n    }\n  }\n\n  return sum === 0 ? 'YES' : 'NO';\n}\n\n/**\n * this solution is not optimal and\n * count sum every loop cycle\n*/\nfunction balancedSumVariant1(arr) {\n  const len = arr.length;\n\n  let leftSum = 0;\n  let rightSum = 0;\n  let leftArr = [];\n  let rightArr = []\n\n\n  if (len === 1) {\n    return 'YES'\n  }\n\n  for (let i = 1; i < len; i++) {\n    leftArr = arr.slice(0, i);\n    leftSum = (leftArr.length > 0) ?\n      leftArr.reduce((accumulator, currentValue) => accumulator + currentValue) :\n      0;\n\n    rightArr = arr.slice(i+1); //rightArr = arr.slice(i, len);\n    rightSum = (rightArr.length > 0) ?\n      rightArr.reduce((accumulator, currentValue) => accumulator + currentValue) :\n      0;\n\n    if (leftSum === rightSum) {\n      return 'YES'\n    }\n  }\n\n  return 'NO'\n}\n\nexport { balancedSum, balancedSumVariant1 }\n","/**\n * Ice Cream parlor\n *\n * Given an array of integers,\n * return indices of the two numbers such that they add up to a specific target.\n * You may assume that each input would have exactly one solution,\n * and you may not use the same element twice.\n */\n\n/**\n * brute force solution\n * runtime O(n2)\n * space complexity is O(1)\n */\nfunction twoSumBruteForce(arr, sum) {\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    for (let j = i + 1; j < len; j++) {\n      if (arr[j] === sum - arr[i]) {\n        return [i, j]\n      }\n    }\n  }\n\n  throw new Error('No two sum solution');\n}\n\n/**\n *\n * Solution using hash, runtime O(n) - linear time\n * The main benefit of using a hash table is the O(1) lookup time.\n * 1 Create an object containing the key-value pairs of the element and its index, respectively.\n * 2 Iterate through an array. For currentElement, compute complement.\n * etc.\n * @param {number[]} arr\n * @param {number} target\n * @return {number[]}\n */\nfunction twoSum(arr, target) {\n  const len = arr.length;\n  const previousValues = {};\n\n  for (let i = 0; i < len; i++) {\n    const currentElement = arr[i];\n    const complement = target - currentElement; // needed\n    const index2 = previousValues[complement];\n    if (index2 != null) {\n      return [index2, i]\n    } else {\n      previousValues[currentElement] = i\n    }\n  }\n\n  // or through an exception\n  return [];\n};\n\n/**\n * 1 Take an arr\n * 2 sort all the items\n * 3 just do a binary search there\n * @param {*} arr\n * @param {*} target\n */\n// todo find a solution\n// function twoSumBinarySearch(arr, target) {\n//   const sortedArr = arr.sort((a,b) =>  a - b);\n//   console.log('arr', arr);\n\n//   let nums = [];\n//   let previousValues = [];\n\n//   for (let i in sortedArr) {\n//     let complement = binarySearchRecursive(sortedArr, target - sortedArr[i]);\n//     if (!!complement && !previousValues.includes[arr[i]] && !previousValues.includes(complement)) {\n//       nums.push([sortedArr[i], complement]);\n//       previousValues.push(complement)\n//     }\n//   }\n\n//   console.log(nums)\n//   return nums;\n// }\n\n//twoSumBinarySearch([2, 7, 11, 15], 9);\n//twoSumBinarySearch([2,3,4,3,6,7], 6);\n\n\nconst twoSumUsingMap = function(arr, target) {\n  const len = arr.length;\n  let map = new Map();\n\n  for (var i = 0; i < len; i++) {\n    let complement = target - arr[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i]\n    }\n     map.set(arr[i], i);\n  }\n  console.log('map', map)\n}\n\nexport { twoSum, twoSumBruteForce, twoSumUsingMap }\n","/**\n * Leetcode javascript\n * 278. First Bad version\n * Easy\n *\n * You are a product manager and currently leading a team to develop a new product.\n * Unfortunately, the latest version of your product fails the quality check.\n * Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n * Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,\n * which causes all the following ones to be bad.\n *\n * You are given an API bool isBadVersion(version) which will return whether version is bad.\n * Implement a function to find the first bad version. You should minimize the number of calls to the API.\n *\n * Example:\n * Given n = 5, and version = 4 is the first bad version.\n *  call isBadVersion(3) -> false\n *  call isBadVersion(5) -> true\n *  call isBadVersion(4) -> true\n */\n\n/*\n  Approach 1 Linear scan: The straight forward way is to brute force it by doing a linear scan.\n\n  Time complexity : O(n). Assume that isBadVersion(version) takes constant time to check if a version is bad.\n  It takes at most n - 1 checks, therefore the overall time complexity is O(n).\n  Space complexity : O(1).\n*/\nvar solutionLinearSearch = function(isBadVersion) {\n  return function(n) {\n    for (let i = 1; i < n; i++) {\n      if (isBadVersion(i) === true) {\n        return i;\n      }\n    }\n    return n;\n  };\n};\n\n/*\n  Approach 2 Binary search\n  Let us see how the search space could be halved each time below.\n\n  Scenario 1\n  where isBadVersion(mid) => false.\n  We know that all versions preceding and including mid are all good.\n  So we set left = mid + 1 to indicate that the new search space is the interval [mid + 1, right] (inclusive).\n\n  Scenario 2\n  The only scenario left is where isBadVersion(mid) => true.\n  This tells us that mid may or may not be the first bad version,\n  ut we can tell for sure that all versions after mid can be discarded.\n  Therefore we set right = mid as the new search space of interval [left,mid] (inclusive).\n\n  Case: left + right can overflow\n  In our case, we indicate left and right as the boundary of our search space (both inclusive).\n  This is why we initialize left = 1 and right = n.\n  How about the terminating condition?\n  We could guess that left and right eventually both meet and it must be the first bad version,\n  but how could you tell for sure?\n  Here is a helpful tip to quickly prove the correctness of your binary search algorithm during an interview.\n  We just need to test an input of size 2.\n  left + right could overflow\n  One way to fix this is to use left + (right - left)/2\n\n  Time complexity: O(log n). The search space is halved each time.\n  Space complexity: O(1)\n*/\n\nvar solutionBinarySearch = function(isBadVersion) {\n  return function(n) {\n    let left = 1;\n    let right = n;\n\n    while (left < right) {\n      // left + right could overflow.\n      let mid = left + (right - left) / 2;\n      if (isBadVersion(mid)) {\n        right = mid // new search [left, mid] (inclusive)\n      } else {\n        left = mid + 1; // search from [mid + 1, right] (inclusive)\n      }\n    }\n  };\n};\n\nexport { solutionLinearSearch, solutionBinarySearch }\n","import React from 'react';\nimport Details from './../Details';\nimport { findIndex } from '../../algorithms/search/find-index';\nimport { binarySearchRecursive, binarySearch } from '../../algorithms/search/binary-search';\nimport { balancedSum } from '../../algorithms/search/balanced-sum';\nimport { twoSum } from \"../../algorithms/search/two-sum\";\nimport { solutionBinarySearch } from '../../leetcode/search/binary-search/278-first-bad-version';\n\nexport default function Searching() {\n  return (\n    <div className=\"number\">\n      <h2>Search</h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"is-find-index\"\n            question=\"Linear search: find an index of element in array\"\n            solution=\"\"\n            complexity=\"The worst case performance scenario for a linear search is that it needs to loop through the entire collection.\"\n            time=\"O(n)\"\n            spaceComplexity=\"O(1)\"\n            code={findIndex.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"binary-search\"\n            question=\"Binary search with loop while and recursion\"\n            solution=\"left + right could overflow, correct mid = left + (right - left)/2\"\n            complexity=\"\"\n            time=\"O(log n)\"\n            space=\"O(1)\"\n            code={binarySearch.toString()}\n            secondCode={binarySearchRecursive.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"search-balanced-sum\"\n            question=\"Balanced sum\"\n            solution=\"challenge is to find an element of the array such that the sum of all elements to the left is equal to the sum of all elements to the right\"\n            complexity=\"\"\n            time=\"O(n)\"\n            code={balancedSum.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"search-two-sum\"\n            question=\"Two sum using hash\"\n            solution={`\n              Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n              You may assume that each input has exactly one solution.\n              And you may not use the same element twice.\n            `}\n            complexity=\"\"\n            time=\"O(n)\"\n            space=\"O(n). The extra space required depends on the number of items stored in the hash table, which stores exactly nn elements\"\n            code={twoSum.toString()}\n          />\n        </li>\n\n        <li>\n          <details\n            className=\"details\"\n            id=\"searching-tasks\"\n            aria-expanded=\"false\"\n            aria-labelledby=\"label\">\n              <summary role=\"button\" aria-controls=\"content\">Different tasks related to Binary search</summary>\n              <Details\n                id=\"first-bad-version\"\n                question=\"First Bad version\"\n                solution={`\n                  Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one,\n                  which causes all the following ones to be bad.\n                `}\n                time=\"O(log n)\"\n                space=\"O(1)\"\n                code={solutionBinarySearch.toString()}\n              />\n          </details>\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","/**\n * Binary Search Tree implementation in JavaScript\n */\n\nclass Node {\n  constructor(value) {\n    this.value = value;\n    this.left = null; // left pointer\n    this.right = null; // right pointer\n  }\n}\n/**\n * Represents a single node in a BinarySearchTree.\n * @class BinarySearchTree\n */\nclass BinarySearchTree {\n  constructor(value) {\n    this.root = new Node(value);\n    this.count = 0; // how many nodes in Tree\n  }\n\n  size() {\n    // count doesn't work correctly with duplicated nodes\n    return this.count;\n  }\n\n  /**\n    * Adds some value into the tree. This method traverses the tree to find\n    * the correct location to insert the value. Duplicate values are discarded.\n    * @param {*} value The value to add to the tree.\n    * @returns {void}\n  */\n  insert(value) {\n    this.count++;\n\n    /*\n      * Create a new node to insert into the tree and store the value in it.\n      * This node will be added into the tree.\n    */\n    let newNode = new Node(value);\n\n    // special case: no nodes in the tree yet\n    if (this.root.value === undefined) {\n      this.root = newNode\n    }\n\n    // search\n    const traverseTree = (node) => {\n      // if value less than node value, go left\n      if (value < node.value) {\n        // if no left child, append new node\n        if (node.left === null) {\n          node.left = newNode\n        }\n        // if left child exists, look left again recursively\n        else {\n          traverseTree(node.left)\n        }\n      }\n      // if value bigger than node value go right\n      else if ( value > node.value) {\n        if (node.right === null) {\n          node.right = newNode\n        }\n        // look searchTree right again\n        else {\n          traverseTree(node.right)\n        }\n      }\n      else {\n        // adding an element that already exists should return null\n        return null\n      }\n    }\n    // call search on root node\n    traverseTree(this.root);\n  }\n\n   /**\n    * The contains() method accepts a value as an argument and\n    * returns true if the value is present in the tree or false if not.\n  */\n  contains(value) {\n    let currentNode = this.root;\n\n    while (currentNode) {\n      if (value === currentNode.value) {\n        return true\n      }\n\n      if ( value < currentNode.value) {\n        currentNode = currentNode.left\n      } else {\n        currentNode = currentNode.right\n      }\n    }\n\n    return false;\n  }\n\n  // im not sure that this is correct solution\n  // height of binary tree, should return '-1' when root is NULL.\n  height(node = this.root) {\n    // empty node\n    if (node === null) return -1;\n\n    if (node.left === null && node.right === null) {\n      return 0\n    }\n\n    if (node.left === null) {\n      return this.height(node.right) + 1\n    }\n\n    if (node.right === null) {\n      return this.height(node.left) + 1\n    }\n\n    const leftHeight = this.height(node.left);\n    const rightHeight = this.height(node.right);\n\n\n    return Math.max(leftHeight, rightHeight) + 1;\n  }\n\n  // Start at root and check if p and q are less, then go left, otherwise go right\n  lowestCommonAncestor(\n    p, // v1\n    q, // v2\n    node = this.root\n  ) {\n    if (node.value > p && node.value > q) {\n      return this.lowestCommonAncestor(p, q, node.left)\n    } else if (node.value < p && node.value < q) {\n      return this.lowestCommonAncestor(p, q, node.right)\n    } else {\n      return node\n    }\n\n  }\n}\n\nconst tree = new BinarySearchTree(4);\n// need to have specific order\n// tree.insert(4)\ntree.insert(2)\ntree.insert(3)\ntree.insert(1)\ntree.insert(7)\ntree.insert(6)\n\n\nconsole.log('tree', tree)\ntree.lowestCommonAncestor(2,7) // should be 4 it's not correct\nconsole.log('lca', tree.lowestCommonAncestor(2,7));\n// console.log('size', tree.size());\n\nexport { BinarySearchTree }\n\n\n","import React from 'react';\nimport Details from '../Details';\nimport { BinarySearchTree } from '../../algorithms/tree/binary-search-tree';\n\nexport default function Tree() {\n  return (\n    <div className=\"number\">\n      <h2>Trees</h2>\n\n      <ul id=\"binary-search-tree\">\n        <li>\n          <Details\n            id=\"binary-search-tree-operations\"\n            question=\"Binary Search Tree: .insert, .contains, height, lowest common ancestor\"\n            solution=\"\"\n            complexity={\n              `\n                Binary search trees provide logarithmic time for the common operations of lookup, insertion, and deletion in the average case,\n                and linear time in the worst case.\n                Why is this? Each of those basic operations requires us to find an item in the tree\n                and because of the tree structure at each parent node we are branching left or right\n                and effectively excluding half the size of the remaining tree.\n                This makes the search proportional to the logarithm of the number of nodes in the tree,\n                which creates logarithmic time for these operations in the average case.\n              `\n            }\n            time=\"O(log(n)) in the average case, linear - in worst cases\"\n            space=\"\"\n            code={BinarySearchTree.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","// construction function\nconst Stack = function() {\n  this.storage = ''; // storage\n}\n\n// push(val) - add value to the front, return size stack\nStack.prototype.push = function(val) {\n  this.storage = this.storage.concat('***', val)\n}\n\n// pop removes value from front and returns value\nStack.prototype.pop = function() {\n  const lastEliminate = this.storage.lastIndexOf('***');\n  // slice off the last characters up until ***\n  const str = this.storage.slice(lastEliminate + 3);\n  // updating a new stack without last item\n  this.storage = this.storage.substr(0, lastEliminate);\n  // return the last item\n  return str;\n}\n\n// size returns size of stack as an integer\nStack.prototype.size = function() {\n  const len = this.storage.length;\n  return len;\n}\n\nconst myWeeklyMenu = new Stack();\nmyWeeklyMenu.push('carrot');\nmyWeeklyMenu.push('eggs');\nmyWeeklyMenu.push('coffee');\nmyWeeklyMenu.pop();\nmyWeeklyMenu.size()\n//console.log('myWeeklyMenu', myWeeklyMenu)\n\nexport { Stack }\n","/**\n * Stack using objects\n * The problem that hash doesn't have last element\n * Idea have a loop for prop in k which is an object\n *  for prop in k\n *    if !k[x-i]\n *      k[x-i] = a\n *      break;\n * @param {*} capacity\n */\nfunction StackObj(capacity) {\n  this.capacity = capacity || Infinity;\n  this.storage = {};\n  this.count = 0;\n}\n\n// O(1)\nStackObj.prototype.push = function(value) {\n  if (this.count < this.capacity) {\n    this.storage[this.count++] = value;\n    return this.count;\n  }\n  return 'Max capacity already reached. Remove element before adding a new one.'\n}\n\n// O(1)\nStackObj.prototype.pop = function() {\n  if (this.count === 0) {\n    return 'No element inside the stack. Add element before popping.'\n  }\n\n  const value = this.storage[this.count--];\n  delete this.storage[this.count];\n  if (this.count < 0) {\n    this.count = 0;\n  }\n  return value;\n}\n\n// O(1)\nStackObj.prototype.count = function() {\n  return this.count;\n}\n\nconst myStack = new StackObj();\nmyStack.push('a');\nmyStack.push('b');\nmyStack.push('c');\n// myStack.pop();\n// console.log('my stack pop', myStack.pop());\n// console.log('my stack', myStack);\n\nexport { StackObj }\n\n\n\n","// construction function\nfunction Queue(capacity) {\n  this.capacity = capacity || Infinity;\n  this.storage = {}\n  this.head = 0;\n  this.tail = 0;\n}\n\nQueue.prototype.count = function() {\n  return this.tail - this.head;\n};\n\nQueue.prototype.enqueue = function(val) {\n  if (this.count() < this.capacity) {\n    this.storage[this.tail++] = val;\n    return this.count();\n  }\n  return 'Max capacity already reached. Remove element before adding a new one.';\n}\n\nQueue.prototype.dequeue = function() {\n  var element = this.storage[this.head];\n  delete this.storage[this.head];\n  if (this.head < this.tail) this.head++;\n  return element;\n}\n\n\n//const myQueue = new Queue(3);\n// console.log('myQueue', myQueue )\n\nexport { Queue }\n\n","import React from 'react';\nimport Details from '../Details';\nimport { Stack } from '../../algorithms/stack/stack-using-string';\nimport { StackObj } from '../../algorithms/stack/stack-using-objects';\nimport { Queue } from '../../algorithms/queue/queue-using-object';\n\nexport default function StackQueue() {\n  return (\n    <div className=\"number\">\n      <h2>Stack and Queue</h2>\n\n      <ul>\n        <li>\n          <Details\n            id=\"stack-using-string\"\n            question=\"Stack implementation using string\"\n            code={Stack.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"stack-using-object\"\n            question=\"Stack implementation using object\"\n            code={StackObj.toString()}\n          />\n        </li>\n\n        <li>\n          <Details\n            id=\"queue-using-object\"\n            question=\"Queue implementation using object\"\n            code={Queue.toString()}\n          />\n        </li>\n      </ul>\n\n  </div>\n  );\n}\n","import React from 'react';\n\nimport Sorting from './concepts/Sorting';\nimport StringManipulation from './concepts/StringManipulation';\nimport CodeSandboxTasks from '../eloquent-tasks/CodeSandboxTasks';\nimport GreedyAlgorithms from './concepts/GreedyAlgorithms';\nimport Number from './concepts/Number';\nimport Recursion from './concepts/Recursion';\nimport ArrayAlgorithms from './concepts/ArrayAlgorithms';\nimport Searching from './concepts/Searching';\nimport Tree from './concepts/Tree';\nimport StackQueue from './concepts/StackQueue';\n\nimport './main.css';\n\nfunction Main() {\n  return (\n    <div className=\"main\">\n      <div className=\"wrapper\">\n        <Number />\n        <Recursion />\n        <ArrayAlgorithms />\n        <Sorting />\n        <StringManipulation />\n        <GreedyAlgorithms />\n        <Searching />\n        <Tree />\n        <StackQueue />\n        <CodeSandboxTasks />\n      </div>\n  </div>\n  );\n}\n\nexport default Main;\n","import React from 'react';\nimport { Component } from 'react';\n//import { boundMethod } from 'autobind-decorator';\nimport SplitPane from 'react-split-pane';\nimport PropTypes from 'prop-types';\nimport { MOBILE_DEVICE, MINSIZE, EXPANDEDSIZE, THRESHOLDSIZE } from './../config/constants';\n\nimport './resizer.css';\n\nconst propTypes = {\n  children: PropTypes.any\n};\n\nexport default class SplitSidebarView extends Component {\n  constructor (props) {\n    super(props);\n\n    const width = window.innerWidth;\n    this.state = {\n      sideBarSize: this.getSize(width),\n      sideBarGrowing: false\n    };\n\n    this.handleDrag = this.handleDrag.bind(this);\n    this.onDragFinished = this.onDragFinished.bind(this);\n    this.onResizerDoubleClick = this.onResizerDoubleClick.bind(this);\n  }\n\n  getSize(windowWidth) {\n    const minCollapsedWidth = MOBILE_DEVICE; // tablet/mobile devices\n    return windowWidth >= minCollapsedWidth ? EXPANDEDSIZE : MINSIZE;\n  }\n\n  handleDrag(size) {\n    if (size !== this.state.sideBarSize) {\n      this.setState({\n        sideBarSize: size,\n        sideBarGrowing: this.state.sideBarSize < size\n      });\n    }\n  }\n\n  onDragFinished() {\n    this.setState({\n      sideBarSize: this.state.sideBarGrowing ? EXPANDEDSIZE : MINSIZE\n    });\n  }\n\n  onResizerDoubleClick(event) {\n    this.setState({\n      sideBarSize: this.state.sideBarSize === MINSIZE ? EXPANDEDSIZE : MINSIZE\n    });\n  }\n\n  render() {\n    const { sideBarSize } = this.state;\n    const { children } = this.props;\n\n    return (\n      <SplitPane\n        className={sideBarSize < THRESHOLDSIZE ? 'sidebarShortVersion' : null}\n        onChange={this.handleDrag}\n        onDragFinished={this.onDragFinished}\n        onResizerDoubleClick={this.onResizerDoubleClick}\n        resizerStyle={{ width: '0' }}\n        split=\"vertical\"\n        minSize={MINSIZE}\n        maxSize={EXPANDEDSIZE}\n        size={sideBarSize}>\n        { children }\n      </SplitPane>\n    );\n  }\n}\n\nSplitSidebarView.propTypes = propTypes;\n","// screen width\nexport const DESKTOP_DEVICE = 1440; // mac 13 inches\nexport const TABLET_DEVICE = 1024;\nexport const MOBILE_DEVICE = 767;\n\n\n// sidebar\nexport const MINSIZE = 67;\nexport const EXPANDEDSIZE = 250;\nexport const THRESHOLDSIZE = (MINSIZE + EXPANDEDSIZE) / 2;\n","import React, { Component } from 'react';\nimport Sidebar from './components/Sidebar';\nimport Main from './components/Main';\nimport SplitSidebarView from './components/SplitSidebarView';\n\nimport \"bootstrap/dist/css/bootstrap.min.css\";\nimport './App.css';\n\nfunction openTarget() {\n  let hash = location.hash.substring(1);  // eslint-disable-line\n\n  if (hash) {\n    var detail = document.getElementById(hash);\n  }\n\n  if (detail && detail.tagName.toLowerCase() === 'details') {\n    detail.open === true ?  detail.open = false : detail.open = true\n  }\n}\n\nclass App extends Component {\n  state = {\n\n  }\n\n  componentDidMount() {\n    window.addEventListener('hashchange', openTarget);\n  }\n\n\n  render() {\n    return (\n      <div className=\"App\">\n        <SplitSidebarView>\n          <Sidebar className=\"sidebar\" />\n          <div className=\"rightPart\">\n              <header className=\"App-header\">\n                Computer Science Algorithms in JavaScript\n              </header>\n              <Main />\n          </div>\n        </SplitSidebarView>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}